# **설계와 아키텍처란?**  
설계(design)와 아키텍처(architecture)의 차이점은 없다.  
  
'아키텍처'는 저수준의 세부사항과는 분리된 고수준의 무언가를 가리킬 때 흔히 사용되는 반면 '설계'는 저수준의 구조 또는 결정사항 들을 의미할 때가 
많다. 하지만 아키텍트가 실제로 하는 일을 살펴보면 이러한 구분은 무의미하다.  
  
새로운 집을 설계하는 아키텍트가 있다고 하자. 이 집은 아키텍처를 가지고 있는가? 당연히 있다. 그렇다면 그 집의 아키텍처는 무엇인가? 아마 집의 형태, 
외관, 입면도, 공간이나 방의 배치 등이 여기에 포함된다. 하지만 아키텍트가 만든 도면을 살펴보면 무수히 많은 저수준의 세부사항도 확인할 수 있다. 
콘센트, 전등 스위치, 전등이 모두 어디에 위치하는지를 도면에서 알 수 있다. 보일러는 어디에 놓이고, 온수기와 배출 펌프의 크기와 위치는 어떻게 되는지 
역시 볼 수 있다. 벽, 지붕 그리고 기초 공사가 어떻게 진행될지도 상세히 확인할 수 있다.  
  
다시 말해 모든 고수준의 결정사항을 지탱하는 모든 세부사항을 자세하게 확인할 수 있다. 이러한 저수준의 세부사항과 고수준의 결정사항은 집의 전체 
설계의 구성요소가 된다.  
  
소프트웨어 설계도 마찬가지다. 저수준의 세부사항과 고수준의 구조는 모두 소프트웨어 전체 설계의 구성요소다. 이 둘은 단절 없이 이어진 직물과 같으며 
이를 통해 대상 시스템의 구조를 정의한다. 개별로는 존재할 수 없고 실제로 이 둘을 구분 짓는 경계는 뚜렷하지 않다. 고수준에서 저수준으로 향하는 
의사결정의 연속성만이 있을 뿐이다.  
  
# **목표는?**  
그렇다면 이러한 의사결정의 목표와 좋은 소프트웨어 설계의 목표는 다음 설명과 크게 다르지 않다.  
  
- 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.  
  
설계 품질을 재는 척도는 고객의 요구를 만족시키는 데 드는 비용을 재는 척도와 다름없다. 이 비용이 낮을 뿐만 아니라 시스템의 수명이 다할 때까지 
낮게 유지할 수 있다면 좋은 설계라고 말할 수 있다. 새로운 기능을 출시할 때마다 비용이 증가한다면 나쁜 설계다. 좋은 설계란 이처럼 단순명료하다.  
  
# **사례 연구**  
다음 사례를 살펴보자. 이 사례는 익명으로 남길 원하는 실제 회사의 진짜 데이터를 바탕으로 만들어졌다.  
  
![img.png](image/img.png)  
  
먼저 엔지니어링 직원 수가 늘어나는 추세를 살펴보자. 분명 이러한 추세를 굉장히 고무적인 상황으로 여길 것이다. 위 그림과 같은 성장은 굉장한 성공을 
이뤄냈음을 가리키는 지표라고 말이다.  
  
![img.png](image/img2.png)  
  
이제 같은 기간 회사의 생산성을 보자. 생산성은 단순히 코드 라인 수로만 측정했다.  
  
무언가 명백히 잘못되었다. 매번 새로운 기능을 출시할 때마다 개발자의 수는 지속적으로 증가했지만 코드 생산성은 마치 한곳으로 수렴하는 것처럼 보인다.  
  
![img.png](image/img3.png)  
  
이제 정말 두려운 그래프를 볼 차례다. 위 그림은 같은 기간에 코드 한 라인당 비용이 어떻게 변했는지를 보여준다.  
  
이 추세로는 오래 갈 수 없다. 지금 당장의 수익성은 중요치 않다. 결국 이러한 비용 곡선은 사업 모델의 수익을 엄청나게 고갈시키며 회사의 성장을 멈추게 
하거나 심지어는 완전히 망하게 만든다.  
  
이처럼 생산성을 현저하게 변화시킨 요인은 대체 무엇인가? 여덟 번째 출시한 제품의 코드는 처음 제품보다 왜 40배나 더 많은 비용이 드는가?  
  
# **엉망진창이 되어 가는 신호**  
지금 보고 있는 것은 엉망진창이 되어 가는 신호다. 시스템을 급하게 만들거나 결과물의 총량을 순전히 프로그래머 수만으로 결정하거나 코드와 설계의 구조를 
깔끔하게 만들려는 생각을 전혀 하지 않으면 파국으로 치닫는 이 비용 곡선에 올라타게 된다.  
  
![img.png](image/img4.png)  
  
위 그림은 이 비용 곡선을 개발자 관점에서 보여준다. 개발자의 생산성은 거의 100%로 시작했지만 출시할 때마다 하락한다. 네 번째 출시에 다다르면 
확실히 생산성은 거의 바닥을 치고 결국에는 0으로 수렴한다.  
  
개발자 입장에서 보자면 이러한 현산은 지독한 절망감을 안겨주는데 모두가 열심히 일하고 있기 때문이다. 전력을 기울이지 않는 개발자는 없다.  
  
개발자가 초인적인 노력을 기울이고 잔업을 하며 헌신함에도 불구하고 더 이상 진척이 없는 상황에 처하게 된다. 개발자의 노력은 기능 개발보다는 엉망이 된 
상황에 대처하는 데 소모되기 시작한다. 심지어 사소한 기능을 추가하는 일도 그저 엉망이 된 코드를 이곳에서 저곳으로, 다시 다음 곳으로 이동하는 반복 
작업으로 변질된다. 개발자들이 쏟은 노력의 가치가 결국 보잘것없게 된다.  
  
