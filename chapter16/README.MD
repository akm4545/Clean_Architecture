# **독립성**  
앞서 서술한 바와 같이 좋은 아키텍처는 다음을 지원해야 한다.  
  
- 시스템의 유스케이스  
- 시스템의 운영  
- 시스템의 개발  
- 시스템의 배포  
  
# **유스케이스**  
유스케이스의 경우 시스템의 아키텍처는 시스템의 의도를 지원해야 한다는 뜻이다. 만약 시스템이 장바구니 애플리케이션라면 이 아키텍처는 장바구니와 관련된 
유스케이스를 지원해야 한다. 실제로 아키텍트의 최우선 관심사는 유스케이스이며 아키텍처에서도 유스케이스가 최우선이다. 아키텍처는 반드시 유스케이스를 
지원해야 한다.  
  
하지만 아키텍처는 시스템의 행위에 그다지 큰 영향을 주지 않는다. 행위와 관련하여 아키텍처가 열어 둘 수 있는 선택사항은 거의 없다. 하지만 영향력이 
전부는 아니다. 좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며 이를 통해 시스템이 지닌 
의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.  
  
장바구니 애플리케이션이 좋은 아키텍처를 갖춘다면 이 애플리케이션은 장바구니 애플리케이션처럼 보일 것이다. 해당 시스템의 유스케이스는 시스템 구조 
자체에서 한눈에 드러날 것이다. 이들 행위는 일급 요소이며 시스템의 최상위 수준에서 알아볼 수 있으므로 개발자가 일일이 찾아 헤매지 않아도 된다. 이들 
요소는 클래스이거나 함수 또는 모듈로서 아키텍처 내에서 핵심적인 자리를 차지할 뿐만 아니라 자신의 기능을 분명하게 설명하는 이름을 가질 것이다.  
  
# **운영**  
시스템의 운영 지원 관점에서 볼 때 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡는다. 시스템이 초당 100000명의 고객을 처리해야 한다면 아키텍처는 이 
요구와 관련된 각 유스케이스에 걸맞은 처리량과 응답시간을 보장해야 한다. 만약 시스템에서 수 밀리초 안에 3차원의 빅데이터 테이블에 질의해야 한다면 반드시 
이러한 운영 작업을 허용할 수 있는 형태로 아키텍처를 구조화해야 한다.  
  
이러한 형태를 지원한다는 말은 시스템에 따라 다양한 의미를 지닌다. 어떤 시스템에서는 시스템의 처리 요소를 일련의 작은 서비스들로 배열하여 서로 다른 
많은 서버에서 병렬로 실행할 수 있게 만들어야 함을 의미한다. 또 다른 시스템에서는 경량의 수많은 스레드가 단일 프로세서에서 같은 주소 공간을 공유하도록 
만든다는 뜻일 수도 있다. 또는 독립된 주소 공간에서 실행되는 소수의 프로세스만으로도 충분한 시스템도 있을 것이다. 심지어 어떤 시스템은 단일 프로세스에서 
실행되는 단순한 모노리틱 프로그램 정도로 살아남기도 한다.  
  
이상하게 보일 수도 있지만 이러한 결정은 뛰어난 아키텍트라면 열어 두어야 하는 선택사항 중의 하나다. 만약 시스템이 단일체(monolith)로 작성되어 모노리틱 
구조를 갖는다면 다중 프로세스, 다중 스레드, 또는 마이크로서비스 형태가 필요해질 때 개선하기가 어렵다. 그에 비해 아키텍처에서 각 컴포넌트를 적절히 
격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 
기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.  
  
# **개발**  
아키텍처는 개발환경을 지원하는 데 있어 핵심적인 역할을 수행한다. 콘웨이의 법칙이 작용하는 지점이 바로 여기다. 콘웨이의 법칙은 다음과 같다.  
  
- 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.  
  
많은 팀으로 구성되며 관심사가 다양한 조직에서 어떤 시스템을 개발해야 한다면 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 
팀들이 서로를 방해하지 않도록 해야 한다. 이러한 아키텍처를 만들려면 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 한다. 
그래야만 이들 컴포넌트를 독립적으로 작업할 수 있는 팀에 할당할 수 있다.  
  
# **배포**  
또한 아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 한다. 이때 목표는 즉각적인 배포다. 좋은 아키텍처는 수십 개의 작은 설정 스크립트나 속성 파일을 
약간씩 수정하는 방식을 사용하지 않는다. 좋은 아키텍처는 꼭 필요한 디렉토리나 파일을 수작업으로 생성하게 내버려 두지 않는다. 좋은 아키텍처라면 시스템이 
빌드된 후 즉각 배포할 수 있도록 지원해야 한다.  
  
다시 말하지만 이러한 아키텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다. 여기에는 마스터(Main 컴포넌트라고도 부른다) 컴포넌트도 
포함되는데 마스터 컴포넌트는 시스템 전체를 하나로 묶고 각 컴포넌트를 올바르게 구동하고 통합하고 관리해야 한다.  
  
# **선택사항 열어놓기**  
좋은 아키텍처는 컴포넌트 구조와 관련된 이 관심사들 사이에서 균형을 맞추고 각 관심사 모두를 만족시킨다.  
  
현실에서는 이러한 균형을 잡기가 매우 어렵다. 대부분의 경우 우리는 모든 유스케이스를 알 수는 없으며 운영하는 데 따르는 제약사항, 팀 구조, 배포 요구사항도 
알지 못하기 떄문이다. 더 심각한 문제는 이러한 사항들을 알고 있더라도, 시스템이 생명주기의 단계를 하나씩 거쳐감에 따라 이 사항들도 반드시 변해간다는 
사실이다. 요컨대 우리가 도달하려는 목표는 뚜렷하지 않을 뿐만 아니라 시시각각 변한다.  
  
그러나 이런 변화 속에서도 사라지지 않는 것이 있다. 몇몇 아키텍처 원칙은 구현하는 비용이 비교적 비싸지 않으며 관심사들 사이에 균형을 잡는데 도움이 된다. 
심지어 균형을 맞추려는 목표점을 명확히 그릴 수 없는 경우에도 도움이 된다. 이들 원칙은 시스템을 제대로 격리된 컴포넌트 단위로 분할할 때 도움이 되며 이를 
통해 선택사항을 가능한 한 많이, 그리고 가능한 한 오랫동안 열어 둘 수 있게 해준다.  
  
좋은 아키텍처는 선택사항을 열어 둠으로써 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.  
  
# **계층 결합 분리**  
유스케이스 측면을 보자. 아키텍트는 필요한 모든 유스케이스를 지원할 수 있는 시스템 구조를 원하지만 유스케이스 전부를 알지는 못한다. 하지만 아키텍트는 
시스템의 기본적인 의도는 분명히 알고 있다. 그 시스템이 장바구니 시스템인지, 자재 명세서 시스템인지, 또는 주문 처리 시스템인지 안다는 뜻이다. 따라서 
아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들을 분리하고 동일한 이유로 변경되는 것들은 
묶는다.  
  
서로 다른 이유로 변경되는 것은 무엇일까? 사용자 인터페이스가 변경되는 이유는 업무 규칙과는 아무런 관련이 없다. 만약 유스케이스가 두 가지 요소를 모두 
포함한다면 뛰어난 아키텍트는 유스케이스에서 UI 부분과 업무 규칙 부분을 서로 분리하고자 할 것이다. 이렇게 함으로써 두 요소를 서로 독립적으로 변경할 
수 있을 뿐만 아니라 유스케이스는 여전히 가시적이며 분명하게 유지할 수 있다.  
  
업무 규칙은 그 자체가 애플리케이션과 밀접한 관련이 있거나 혹은 더 범용적일 수도 있다. 예를 들어 입력 필드 유효성 검사는 애플리케이션 자체와 밀접하게 
관련된 업무 규칙이다. 반대로 계좌의 이자 계산이나 재고품 집계는 업무 도메인에 더 밀접하게 연관된 업무 규칙이다. 이들 서로 다른 두 유형의 규칙은 각자 
다른 속도로, 그리고 다른 이유로 변경될 것이다. 따라서 이들 규칙은 서로 분리하고 독립적으로 변경할 수 있도록 만들어야만 한다.  
  
데이터베이스, 쿼리 언어, 심지어 스키마조차도 기술적인 세부사항이며 업무 규칙이나 UI와는 아무런 관련이 없다. 이들은 시스템의 다른 측면과는 다른 속도로 
그리고 다른 이유로 변경된다. 결론적으로 아키텍트는 이들을 시스템의 나머지 부분으로부터 분리하여 독립적으로 변경할 수 있도록 해야만 한다.  
  
이제 우리는 시스템을 서로 결합되지 않은 수평적인 계층으로 분리하는 방법을 알게 되었다. 이러한 계층의 예로는 UI, 애플리케이션에 특화된 업무 규칙, 
애플리케이션과는 독립적인 업무 규칙, 데이터베이스 등을 들 수 있다.  
  

