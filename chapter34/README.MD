# **빠져 있는 장**  
지금까지 읽은 모든 조언은 더 나은 소프트웨어를 설계하는 데 확실히 도움이 될 것이다. 이러한 소프트웨어는 올바르게 정의된 경계, 명확한 책임, 그리고 통제된 
의존성을 가진 클래스와 컴포넌트로 구성될 것이다. 하지만 악마는 항상 디테일(구현 세부사항)에 있는 법이며 이점을 심사숙고하지 않는다면 마지막 고비에 
걸려 넘어지기 십사일 것이다.  
  
예를 들어 온라인 서점을 구축하고 있으며 고객이 주문 상태를 조회할 수 있어야 한다는 유스케이스를 구현해야 한다고 해 보자. 비록 이 예제에서는 자바를 
사용하지만 그 원칙은 다른 프로그래밍 언어에도 똑같이 적용된다. 클린 아키텍처는 잠시 한쪽으로 제쳐 놓고 설계나 코드 조직화와 관련된 몇 가지 접근법을 
살펴보자.  
  
# **계층 기반 패키지**  
아마도 가장 단순한 첫 번째 설계 방식은 전통적인 수평 계층형 아키텍처다. 기술적인 과점에서 해당 코드가 하는 일에 기반해 그 코드를 분할한다. 흔히 
우리는 이 방식을 계층 기반 패키지라고 부른다.  
  
![img.png](image/img.png)  
  
위 그림의 UML 클래스 다이어그램에서 계층 기반 패키지가 어떤 모습인지 볼 수 있다.  
  
이 전형적인 계층형 아키텍처에는 웹, 업무 규칙, 영속성 코드를 위해 계층이 각각 하나씩 존재한다. 다시 말해 코드는 계층이라는 얇은 수평 조각으로 
나뉘며 각 계츠응ㄴ 유샇ㄴ 종류의 것들을 묶는 도구로 사용된다. 엄격한 계층형 아키텍처의 경우 계층은 반드시 바로 아래 계층에만 의존해야 한다. 
자바의 경우 계층은 주로 패키지로 구현된다. 그림에서 보듯이 계층(패키지) 사이의 의존성은 모두 아래를 향한다. 이 예에서는 다음의 자바 타입들이 존재한다.  
  
- OrdersController: 웹 컨트롤러이며 웹 기반 요청을 처리한다. Spring MVC 컨트롤러 등이 여기 해당한다.  
- OrderService: 주문 관련 업무 규칙을 정의하는 인터페이스  
- OrderServiceImpl: OrderService의 구현체 (이러한 클래스 명명법은 끔찍한 방시김이 거의 틀림없다. 하지만 나중에 보겠지만 이러한 명명법이 큰 
문제가 되지 않을 수도 있다)  
- OrdersRepository: 영구 저장된 주문 정보에 접근하는 방법을 정의하는 인터페이스  
- JdbcOrdersRepository: OrdersRepository 인터페이스의 구현체  
  
마틴 파울러는 프레젠테이션 도메인 데이터 계층화에서 처음 시작하기에는 계층형 아키텍처가 적합하다고 얘기했다. 이게 마틴 만의 얘기는 아니다. 다수의 책, 
튜토리얼, 교육 과정, 샘플 코드 또한 계층형 아키텍처를 만드는 길로 인도한다. 이 아키텍처는 엄청난 복잡함을 겪지 않고도 무언가를 작동시켜 주는 
아주 빠른 방법이다. 문제는 마틴이 지적했듯이 소프트웨어가 커지고 복잡해지기 시작하면 머지 않아 큰 그릇 세 개만으로 모든 코드를 담기엔 부족하다는 
사실을 깨닫고 더 잘게 모듈화해야 할지를 고민하게 될 것이다.  
  
엉클 밥이 이미 언급했듯이 계층형 아키텍처는 업무 도메인에 대해 아무것도 말해주지 않는다는 문제도 있다. 전혀 다른 업무 도메인이라도 코드를 계층형 
아키텍처로 만들어서 나란히 놓고 보면 웹, 서비스, 리포지터리로 구성된 모습이 기분 나쁠 정도로 비슷하게 보일 것이다. 계층형 아키텍처는 이 밖에도 
큰 문제가 있다.  
  
# **기능 기반 패키지**  
코드를 조직화하는 또 다른 선택지로 기능 기반 패키지 구조도 있다. 이는 서로 연관된 기능, 도메인 개념, 또는 (도메인 주도 설계 용어를 사용한다면) 
Aggregate Root(도메인 주도 설계에 나온 개념으로 AggreGate는 데이터 변경의 단위로 다루는 연관 객체의 묶음이다. 모든 Aggregate는 Root를 가지며 
외부에서 객체에 접근할 때는 반드시 Aggregate Root를 통해야 한다)에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식이다. 전형적인 구현에서는 
모든 타입이 하나의 자바 패키지에 속하며 패키지 이름은 그 안에 담긴 개념을 반영해 짓는다.  
  
![img.png](image/img2.png)  
  
위 그림에서 보듯이 등장하는 인터페이스와 클래스는 이전과 같지만 모두가 (세 개가 아닌) 단 하나의 패키지에 속하게 된다. 이는 계층 기반 패키지를 
아주 간단히 리팩토링한 형태지만 이제 코드의 상위 수준 구조가 업무 도메인에 대해 무언가를 알려주게 된다. 드디어 우리는 이 코드 베이스가 웹, 서비스, 
피로지터리가 아니라 주문과 관련한 무언가를 한다는 걸 볼 수 있다.  
  
또 다른 이점으로 주문 조회하기 유스케이스가 변경될 경우 변경해야 할 코드를 모두 찾는 작업이 더 쉬워질 수 있다. 변경해야 할 코드가 여러 군데 퍼져 
있지 않고 모두 한 패키지에 담겨 있기 떄문이다.  
  
소프트웨어 개발팀이 수평적 계층화(계층 기반 패키지)의 문제를 깨닫고 수직적 계층화(기능 기반 패키지)로 전환하는 걸 자주 목격했다. 두 접근법은 모두 
차선책이다.  
  
