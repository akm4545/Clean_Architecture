# **요약**  
요약하면 다음과 같다. GUI는 세부사항이다. 웹은 GUI다. 따라서 웹은 세부사항이다. 그리고 아키텍트라면 이러한 세부사항을 핵심 업무 로직에서 분리된 
경계 바깥에 두어야 한다.  
  
이렇게 생각해 보자. 웹은 입출력 장치다. 1960년대에 우리는 애플리케이션을 장치 독립적으로 만들면 어떤 가치가 있는지 배웠다. 장치 독립적으로 만들어야 
했던 동기 자체는 지금도 유효하다. 웹도 이 규칙에서 예외가 될 수 없다.  
  
아니면 혹시 웹이라면 예외가 될 수도 있지 않을까? 그 근거로 웹과 같은 GUI는 너무 특이하고 다채롭기 떄문에 장치 독립적인 아키텍처를 추구하는 일이 
터무니없다고 말할 수도 있다. 자바스크립트의 유효성 검증이나 드래그-앤-드롭 방식의 AJAX 호출, 그리고 웹 페이지에 넣을 수 있는 다른 무수한 위젯과 
가젯으로 인한 복잡함을 생각해 볼 때 웹에서 장치 독립성은 비현실적이라고 주장하기 쉽다.  
  
이 주장이 어느 정도는 옳다. 애플리케이션과 GUI의 상호작용은 빈번하며 또한 이러한 상호작용 방식도 사용 중인 GUI 종류에 따라 차이가 매우 크다. 
브라우저와 웹 애플리케이션이 함께 추는 춤은 데스크톱 GUI와 데스크톱 애플리케이션이 함께 추는 춤과는 차이가 난다. 이 같은 춤을 추상화하려는 시도는 
유닉스로부터 장치를 추상화했던 것과는 달리 성공할 가능성이 없어 보인다.  
  
하지만 UI와 애플리케이션 사이에는 추상화가 가능한 또 다른 경계가 존재한다. 업무 로직은 다수의 유스케이스로 구성되며 각 유스케이스는 사용자를 대신해서 
일부 함수를 수행하는 것으로 볼 수 있다. 각 유스케이스는 입력 데이터, 수행할 처리 과정, 출력 데이터를 기반으로 기술할 수 있다.  
  
UI와 애플리케이션이 함께 춤추는 동안 어떤 시점이 되면 입력 데이터가 완전히 구성될 것이고 그러면 유스케이스를 실행할 수 있게 된다. 유스케이스가 
종료되면 해당 입력 데이터에 따른 결과 데이터는 UI와 애플리케이션이 함께 추는 춤으로 다시 되돌려줄 수 있다.  
  
완전한 입력 데이터와 그에 따른 출력 데이터는 데이터 구조로 만들어서 유스케이스를 실행하는 처리 과정의 입력 값과 출력 값으로 사용할 수 있다. 이 
방식을 따르면 각 유스케이스가 장치 독립적인 방식으로 UI라는 입출력 장치를 동작시킨다고 간주할 수 있다.  
  
# **결론**  
이러한 종류의 추상화는 만들기 쉽지 않고 제대로 만들려면 수차례의 반복 과정을 거쳐야 할 것이다. 하지만 가능하다. 그리고 세상은 마케팅 귀재로 가득하기 
떄문에 이러한 추상화가 꼭 필요할 때가 많다고 주장하기는 어렵지 않다.  
  
