# **컴포넌트 결합**  
지금부터 다룰 세 가지 원칙은 컴포넌트 사이의 관계를 설명한다. 이 장에서도 마찬가지로 개발 가능성과 논리적 설계 사이의 균형을 다룬다. 컴포넌트 
구조와 관련된 아키텍처를 침범하는 힘은 기술적이며, 정치적이고, 가변적이다.  
  
# **ADP: 의존성 비순환 원칙**  
- 컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안 된다.  
  
하루 종일 일해서 무언가를 작동하게 만들어 놓고 퇴근했는데 이틑날 출근해 보면 전혀 돌아가지 않는 경험을 해본 적이 있지 않은가? 왜 작동하지 않게 
되었나? 왜냐하면 누군가 당신보다 더 늦게까지 일하면서 당신이 의존하고 있던 무언가를 수정했기 때문이다. 저자는 이러한 현상을 숙취 증후군이라고 부른다.  
  
숙취 증후군은 많은 개발자가 동일한 소스 파일을 수정하는 환경에서 발생한다. 소수의 개발자로 구성된 상대적으로 작은 프로젝트에서는 이 증후군이 그다지 
큰 문제가 되지 않는다. 하지만 프로젝트와 개발팀 규모가 커지면 숙취는 지독한 악몽이 될 수도 있다. 개발팀이 프로젝트의 안정 버전을 빌드하지 못한 채 
몇 주가 그냥 흘러가버리는 일도 드물지 않다. 빌드는 커녕 개발팀 모두가 누군가가 마지막으로 수정한 코드 떄문에 망가진 부분이 동작하도록 만들기 위해 
코드를 수정하고 또 수정하는 작업만이 계속될 뿐이다.  
  
지난 수십 년 동안 이 문제의 해결책으로 두 가지 방법이 발전되어 왔는데 이 두 해결책은 모두 통신 업계에서 만들어졌다. 첫 해결책은 주 단위 빌드(weekly build) 
이며 두 번째 해결책은 의존성 비순환 원칙(Acyclic Dependencies Principle, ADP)이다.  
  
# **주 단위 빌드(Weekly Build)**  
주 단위 빌드는 중간 규모의 프로젝트에서는 흔하게 사용된다. 주 단위 빌드를 하는 방법은 다음과 같다. 먼저 모든 개발자는 일주일의 첫 4일 동안은 서로를 
신경 쓰지 않는다. 개발자는 모두 코드를 개인적으로 복사하여 작업하며 전체적인 기준에서 작업을 어떻게 통합할지는 걱정하지 않는다. 그런 후 금요일이 되면 
변경된 코드를 모두 통합하여 시스템을 빌드한다.  
  
이 접근법은 5일 중 4일 동안 개발자를 고립된 세계에서 살 수 있게 보장해 준다는 아주 멋진 장점을 가진다. 물론 단점은 금요일에 통합과 관련된 막대한 업보를 
치러야 한다는 사실이다.  
  
안타깝게도 프로젝트가 커지면 프로젝트 통합은 금요일 하루 만에 끝마치는 게 불가능해진다. 통합이라는 짐은 점점 커지고 결국 토요일까지 넘어가기 시작한다. 
토요일까지 지연되는 현상이 반복되면 개발자는 통합을 적어도 목요일에는 시작해야 한다고 확신하게 된다. 그러면서 통합을 시작하는 날이 한 주의 중반을 
향해 슬금슬금 움직이게 된다.  
  
개발보다 통합에 드는 시간이 늘어나면서 팀의 효율성도 서서히 나빠진다. 결국 이러한 상황에 봉착하면 개발자나 프로젝트 관리자는 불만이 쌓이고 빌드를 
격주로 해야 한다고 딱 잘라 말하게 된다. 격주 빌드는 잠깐 동안은 만족스럽겠지만 프로젝트 규모가 성장하면서 통합에 드는 시간은 계속해서 늘어난다.  
  
이 같은 흐름은 마침내 위기를 초래한다. 효율성을 유지하기 위해 빌드 일정을 계속 늘려야 하고 빌드 주기가 늦어질수록 프로젝트가 감수할 위험은 커진다. 
통합과 테스트를 수행하기가 점점 더 어려워지고 팀은 빠른 피드백을 주는 장점을 잃는다.  
  
# **순환 의존성 제거하기**  
이 문제의 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다. 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 
작업 단위가 된다. 개발자가 해당 컴포넌트가 동작하도록 만든 후 해당 컴포넌트를 릴리스하여 다른 개발자가 사용할 수 있도록 만든다. 담당 개발자는 이 
컴포넌트에 릴리스 번호를 부여하고 다른 팀에서 사용할 수 있는 디렉토리로 이동시킨다. 그런 다음 개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정한다. 
나머지 개발자는 릴리스된 버전을 사용한다.  
  
컴포넌트가 새로 릴리스되어 사용할 수 있게 되면 다른 팀에서는 새 릴리스를 당장 적용할지를 결정해야 한다. 적용하지 않기로 했다면 그냥 과거 버전의 
릴리스를 계속 사용한다. 새 릴리스를 적용할 준비가 되었다는 판단이 들면 새 릴리스를 사용하기 시작한다.  
  
따라서 어떤 팀도 다른 팀에 의해 좌우되지 않는다. 특정 컴포넌트가 변경되더라도 다른 팀에 즉각 영향을 주지는 않는다. 각 팀은 특정 컴포넌트가 새롭게 
릴리스되면 자신의 컴포넌트를 해당 컴포넌트에 맞게 수정할 시기를 스스로 결정할 수 있다. 뿐만 아니라 통합은 작고 점진적으로 이뤄진다. 특정 시점에 모든 
개발자가 한데 모여서 진행 중인 작업을 모두 통합하는 일은 사라진다.  
  
이 같은 작업 절차는 단순하며 합리적이어서 널리 사용되는 방식이다. 하지만 이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 
관리해야 한다. 의존성 구조에 순환이 있어서는 안 된다. 의존성 구조에 순환이 생기면 숙취 증후군을 피해 갈 수 없다.  
  
![img.png](image/img.png)  
  
위 그림의 컴포넌트 다이어그램에서는 컴포넌트를 조립하여 애플리케이션을 만드는 다소 전형적인 구조를 볼 수 있다. 이 애플리케이션이 수행하는 기능이 
무엇인지는 이 예제에서 설명하려는 목적과는 관련이 없다. 중요한 점은 컴포넌트 간의 의존성 구조다. 이 구조가 방향 그래프(directed graph)임에 
주의하자. 컴포넌트는 정점(vertex)에 해당하고 의존성 관계는 방향이 있는 간선(directed edge)에 해당한다.  
  
한 가지 더 주목할 점이 있다. 어느 컴포넌트에서 시작하더라도 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없다는 사실이다. 이 구조에는 
순환이 없다. 즉 이 구조는 비순환 방향 그래프(Directed Acyclic Graph, DAG)다.  
  
이제 Presenters를 담당하는 팀에서 이 컴포넌트의 새로운 릴리스를 만들면 무슨 일이 벌어질지를 생각해 보자. 이 릴리스에 영향받는 팀은 쉽게 찾을 
수 있다. 의존성 화살표를 거꾸로 따라가면 된다. 즉 View와 Main 컴포넌트 둘 다 영향을 받는다. 이 두 컴포넌트를 작업 중인 개발자라면 Presenters의 
새로운 릴리스와 자신의 작업물을 언제 통합할지를 반드시 결정해야 한다.  
  
또한 Main은 새로 릴리스되더라도 시스템에서 이로 인해 영향받는 컴포넌트가 전혀 없다는 사실에 주목하자. 나머지 컴포넌트는 Main에 대해 알지 못하므로 
Main이 변경되더라도 전혀 개의치 않는다. 멋진 일이다. 즉 Main을 릴리스함으로써 미치게 되는 충격은 대체로 작다는 뜻이다.  
  
Presenters 컴포넌트를 만드는 개발자가 이 컴포넌트를 테스트하고자 한다면 단순히 현재 사용 중인 버전의 Interactors와 Entities를 이용해서 Presenters 
자체 버전을 빌드하면 그만이다. 이 빌드 과정에 시스템의 나머지 컴포넌트는 전혀 관련이 없다. 멋진 일이다. 즉 Presenters를 만드는 개발자가 테스트를 
구성할 때 대체로 적은 노력이 든다는 뜻이며 고려해야 할 변수도 상대적으로 적다는 뜻이기도 하다.  
  
시스템 전체를 릴리스해야 할 때가 오면 릴리스 절차는 상향식으로 진행된다. 먼저 Entities 컴포넌트를 컴파일하고, 테스트하고, 릴리스한다. 그러고 나서 
Database와 Interactors에 대해서도 동일한 과정을 거친다. 그다음에는 Presenters, View, Controllers, Authorizer 순으로 진행한다. Main은 
마지막에 처리한다. 이 같은 절차는 상당히 명료하며 쉽게 처리할 수 있다. 이처럼 구성요소 간 의존성을 파악하고 있으면 시스템을 빌드하는 방법을 알 수 
있다.  
  
