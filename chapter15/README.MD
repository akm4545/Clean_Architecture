# **아키텍처**  
# **아키텍처란?**  
아키텍처(architecture)라는 단어는 권력과 신비로움을 연상케 한다. 아키텍처란 단어는 중대한 결정과 심도 있는 기술적 기량을 떠올리게 한다. 소프트웨어 
아키텍처는 기술적 성취의 정점에 서 있다. 소프트웨어 아키텍트를 생각할 때면 권한을 가지며 존경심을 불러일으키는 사람을 떠올린다.  
  
그러면 소프트웨어 아키텍처란 무엇인가? 소프트웨어 아키텍트는 무슨 일을 하며 언제 그 일을 하는가?  
  
무엇보다도 소프트웨어 아키텍트는 프로그래머이며 앞으로도 계속 프로그래머로 남는다. 소프트웨어 아키텍트라면 코드에서 탈피하여 고수준의 문제에 집중해야 
한다는 거짓말에 절대로 속아 넘어가서는 안 된다. 소프트웨어 아키텍트는 코드와 동떨어져서는 안 된다. 소프트웨어 아키텍트는 최고의 프로그래머이며 
앞으로도 계속 프로그래밍 작업을 맡을 뿐만 아니라 동시에 나머지 팀원들이 생산성을 극대화할 수 있는 설계를 하도록 방향을 이끌어 준다. 소프트웨어 
아키텍트는 다른 프로그래머만큼 코드를 많이 작성하지 않을 수도 있지만 프로그래밍 작업에는 지속적으로 참여한다. 프로그래밍 작업을 계속하는 이유는 
발생하는 문제를 경험해보지 않는다면 다른 프로그래머를 지원하는 작업을 제대로 수행할 수 없기 때문이다.  
  
소프트웨어 시스템의 아키텍처란 시스템을 구축했던 사람들이 만들어낸 시스템의 형태다. 그 모양은 시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 
배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에 따라 정해진다.  
  
그리고 그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만들어진다.  
  
- 이러한 일을 용이하게 만들기 위해서는 가능한 한 많은 선택지를, 가능한 한 오래 남겨두는 전략을 따라야 한다.  
  
이 정의에 놀랐을 수도 있다. 아마도 소프트웨어 아키텍처의 목표가 시스템을 제대로 동작하도록 만드는 데 있다고 생각하고 있었을 것이다. 물론 우리는 
시스템이 제대로 동작하기를 바라며 시스템 아키텍처는 이를 최우선 목표 중 하나로 지원해야 한다.  
  
그러나 시스템 아키텍처는 시스템의 동작 여부와는 거의 관련이 없다. 형편없는 아키텍처를 갖춘 시스템도 수없이 많지만 그런대로 잘 동작한다. 이러한 
시스템들은 대체로 운영에서는 문제를 겪지 않는다. 운영보다 배포, 유지보수, 계속되는 개발 과정에서 어려움을 겪는다.  
  
그렇다고 해서 아키텍처가 시스템이 제대로 동작하도록 지원하는 데 아무런 역할을 하지 않는다는 말은 아니다. 아키텍처는 분명히 그러한 역할을 하며 이 
역할은 대단히 중요하다. 하지만 이 역할은 수동적이며 피상적인 것이지 능동적이거나 본질적인 것은 아니다. 행위에 대해 시스템 아키텍처의 선택지는 설령 
있더라도 매우 적다.  
  
아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다. 좋은 아키텍처는 시스템을 쉽게 이해하고 쉽게 개발하며 쉽게 유지보수하고 또 쉽게 배포하게 
해준다. 아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고 프로그래머의 생산성은 최대화하는 데 있다.  
  
# **개발**  
개발하기 힘든 시스템이라면 수명이 길지도 않고 건강하지도 않을 것이다. 따라서 시스템 아키텍처는 개발팀(들)이 시스템을 쉽게 개발할 수 있도록 뒷받침해야만 
한다.  
  
팀 구조가 다르다면 아키텍처 관련 결정에서도 차이가 난다. 일례로 팀이 개발자 다섯 명으로 구성될 정도로 작다면 잘 정의된 컴포넌트나 인터페이스가 없더라도 
서로 효율적으로 협력하여 모노리틱(monolithic) 시스템을 개발할 수 있다. 사실 이러한 팀이라면 개발 초기에는 아키텍처 관련 제약들이 오히려 방해가 
된다고 여길 가능성이 높다. 수많은 시스템에서 좋은 아키텍처가 결여된 이유는 바로 이 떄문이다. 다시 말해 이러한 팀은 아키텍처 없이 시작하는데 팀 규모가 
작은 데다가 상위 구조로 인한 장애물이 없기를 바라기 떄문이다.  
  
다른 한편으로 일곱 명씩으로 구성된 총 다섯 팀이 시스템을 개발하고 있다면 시스템을 신뢰할 수 있고 안정된 인터페이스를 갖춘, 잘 설계된 컴포넌트 단위로 분리하지 
않으면 개발이 진척되지 않는다. 다른 요소를 고려하지 않는다면 이 시스템의 아키텍처는 다섯 개의 컴포넌트로(즉, 각 팀마다 하나씩) 발전될 가능성이 높다.  
  
이러한 팀별 단일 컴포넌트 아키텍처가 시스템을 배포, 운영, 유지보수하는 데 최적일 가능성은 거의 없다. 그럼에도 여러 팀이 순전히 일정에만 쫓겨서 일한다면 
결국 이 아키텍처로 귀착될 것이다.  
  
