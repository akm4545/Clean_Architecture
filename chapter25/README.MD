# **계층과 경계**  
시스템이 세 가지 컴포넌트(UI, 업무 규칙, 데이터베이스)로만 구성된다고 생각하기 쉽다. 몇몇 단순한 시스템에서는 이 정도로 충분하다. 하지만 대다수의 
시스템에서 컴포넌트의 개수는 이보다 훨씬 많다.  
  
# **움퍼스 사냥 게임**  
1972년에 발매된 모험 게임인 움퍼스 사냥이 있다. 텍스트를 기반으로 하는 이 게임은 GO EAST와 SHOOT WEST와 같은 매우 단순한 명령어를 사용한다. 
  
텍스트 기반 UI는 그대로 유지하되 게임 규칙과 UI를 분리해서 우리 제품을 여러 시장에서 다양한 언어로 발매할 수 있게 만든다고 가정해 보자. 게임 규칙은 
언어 독립적인 API를 사용해서 UI 컴포넌트와 통신할 것이고 UI는 API를 사람이 이해할 수 있는 언어로 변환할 것이다.  
  
![img.png](image/img.png)  
  
위 그림처럼 소스 코드 의존성을 적절히 관리하면 UI 컴포넌트가 어떤 언어를 사용하더라도 게임 규칙을 재사용할 수 있다. 게임 규칙은 어떤 종류의 
인간 언어가 사용되는지 알지도 못할 뿐만 아니라 신경 쓸 이유도 없다.  
  
또한 게임의 상태를 영속적인 저장소에 유지한다고 가정해 보자. 그게 플래시 메모리나 클라우드, 혹은 단순히 RAM일 수도 있다. 어떤 경우라도 우리는 
게임 규칙이 이러한 세부사항을 알지 않기를 바란다. 따라서 이번에도 역시 API를 생성하여 게임 규칙이 데이터 저장소 컴포넌트와 통신할 때 사용하도록 
만든다.  
  
![img.png](image/img2.png)  
  
우리는 게임 규칙이 다양한 종류의 데이터 저장소에 대해 알지 않기를 원한다. 따라서 위 그림에서 보듯이 의존성 규칙을 준수할 수 있도록 의존성이 
적절한 방향을 가리키게 만들어야 한다.  
  
